{biffweb-com-feed
 {:cached nil,
  :request-time 735,
  :repeatable? false,
  :protocol-version {:name "HTTP", :major 1, :minor 1},
  :streaming? true,
  :chunked? false,
  :reason-phrase "OK",
  :headers
  {"server" "Netlify",
   "age" "71177",
   "cache-status" "\"Netlify Edge\"; hit",
   "content-type" "application/xml",
   "content-length" "21237",
   "strict-transport-security" "max-age=31536000",
   "connection" "close",
   "x-nf-request-id" "01KE4YHWARGR2NKR98ZPVJ7XS9",
   "accept-ranges" "bytes",
   "etag" "\"dc112e3ff43f34679b262a6c31fa3d42-ssl-df\"",
   "date" "Sun, 04 Jan 2026 16:48:23 GMT",
   "vary" "Accept-Encoding",
   "cache-control" "public,max-age=0,must-revalidate"},
  :orig-content-encoding "gzip",
  :status 200,
  :length 21237,
  :body
  "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<feed xmlns=\"http://www.w3.org/2005/Atom\"><title>Biff</title><id>https://biffweb.com/feed.xml</id><updated>2025-11-09T11:00:00.000Z</updated><link rel=\"self\" href=\"https://biffweb.com/feed.xml\" type=\"application/atom+xml\" /><link href=\"https://biffweb.com\" /><entry><title type=\"html\">Biff support for XTDB v2 is in pre-release</title><id>https://biffweb.com/p/xtdb2-prerelease/</id><updated>2025-11-09T11:00:00.000Z</updated><content type=\"html\">&lt;p&gt;I've been working on/preparing for migrating Biff to XTDB v2 since that &lt;a href=\"https://xtdb.com/blog/launching-xtdb-v2\"&gt;became generally\navailable&lt;/a&gt; in June. After investigating the deployment\noptions and performance characteristics, I've added some XTDB v2 helper functions to the Biff\nlibrary (under a new &lt;code&gt;com.biffweb.experimental&lt;/code&gt; namespace) and I've made a version of the starter\nproject that uses XTDB v2.&lt;/p&gt;\n&lt;p&gt;You can create a new XTDB v2 Biff project by running &lt;code&gt;clj -M -e '(load-string (slurp &amp;quot;https://biffweb.com/new.clj&amp;quot;))' -M xtdb2&lt;/code&gt;. See &lt;a href=\"https://gist.github.com/jacobobryant/7c2853f2fa391d8d30f19f363709ffc5\"&gt;this\ngist&lt;/a&gt; for a diff between the\nold/main starter project and this new one.&lt;/p&gt;\n&lt;p&gt;To give you a quick overview of what Biff provides:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;There are &lt;code&gt;use-xtdb2&lt;/code&gt; and &lt;code&gt;use-xtdb2-listener&lt;/code&gt; components, roughly the same as we have already for\nXTDB v1.&lt;/li&gt;\n&lt;li&gt;The &lt;code&gt;ctx&lt;/code&gt; map will have a &lt;code&gt;:biff/conn&lt;/code&gt; key in it (a Hikari connection pool object) which you can\npass to &lt;code&gt;xtdb.api/q&lt;/code&gt; to do queries.&lt;/li&gt;\n&lt;li&gt;There is no longer a custom Biff transaction format. There is still a lightweight wrapper\nfunction, &lt;code&gt;com.biffweb.experimental/submit-tx&lt;/code&gt;, which will apply Malli validation to any\n&lt;code&gt;:put-docs&lt;/code&gt; / &lt;code&gt;:patch-docs&lt;/code&gt; operations.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;There's still plenty of work to do before XTDB v2 support in Biff is officially released and becomes\nthe default:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Next up, I'm migrating &lt;a href=\"https://github.com/jacobobryant/yakread\"&gt;Yakread&lt;/a&gt; to XTDB v2. This will\nhelp me find any more issues that need to be addressed/make sure that Biff is indeed ready for\nXTDB v2.&lt;/li&gt;\n&lt;li&gt;After that I need to update a bunch of documentation, including the tutorial project.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Since those next two steps will take a while, I wanted to do this &amp;quot;pre-release&amp;quot; for anyone who would\nlike to get a head start on trying out Biff with XTDB v2. If you do so, let me know whatever\nquestions/comments you have. Just note that the new functions in Biff's API are still experimental\nand might have breaking changes before I do the official release.&lt;/p&gt;\n&lt;p&gt;And for anyone who would rather not deal with migrating an existing app, Biff will still support\nXTDB v1. It's totally fine to stay on that.&lt;/p&gt;\n&lt;p&gt;Finally: I'll be at Clojure/Conj next week, at least if my flight doesn't get canceled. Come say hi.&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/xtdb2-prerelease/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Relaunching Yakread: an algorithmic reading app</title><id>https://biffweb.com/p/yakread-relaunch/</id><updated>2025-09-06T12:30:00.000Z</updated><content type=\"html\">&lt;p&gt;I've recently finished a year-long rewrite of the Yakread\n&lt;a href=\"https://github.com/jacobobryant/yakread\"&gt;codebase&lt;/a&gt; and have released it under a source-available\nlicense. &lt;a href=\"https://yakread.com/\"&gt;Yakread&lt;/a&gt; is a reading app that makes heavy use of algorithmic\nrecommendation/filtering. I originally launched it in 2022 during the last leg of my time as a\nfull-time entrepreneur. It's written with &lt;a href=\"https://biffweb.com/\"&gt;Biff&lt;/a&gt;, a Clojure web framework that\nI also created during that time.&lt;/p&gt;\n&lt;p&gt;I'm publishing Yakread's source code mainly so that it can serve as\na non-toy example project for Biff users. It's about 10K lines of code as of writing. I'm also\nusing Yakread to experiment with potential framework features before adding them into Biff.&lt;/p&gt;\n&lt;h3 id=\"the-app\"&gt;The app&lt;/h3&gt;\n&lt;p&gt;I like reading stuff on the internet. Social media tends to be pretty shallow, though. Long-form\ncontent (articles, blogs, newsletters) is better on average but can take more work to manage: RSS\nreaders and email inboxes tend to get filled up pretty easily, and sorting things chronologically\nbenefits the most frequent publishers. I've found there's a certain amount of mental overhead\nassociated with long-form content that, when you have only a few minutes to read something, often\nmakes it easier to just pull up Reddit.&lt;/p&gt;\n&lt;p&gt;Yakread is my attempt to make reading long-form content as frictionless as reading social media.\nIt's structured as a daily email with links to articles. New users start out getting five links a\nday to articles that were liked by other Yakread users. You can also add your own newsletter/RSS\nsubscriptions to Yakread, and there's support for bookmarking individual articles to read later a la\nPocket or Instapaper. Posts from these content sources are also compiled algorithmically so that:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Blogs that publish a few times per year don't get buried by daily newsletters and other frequent\npublishers.&lt;/li&gt;\n&lt;li&gt;Subscriptions that you interact with the most don't get buried by dozens of other subscriptions\nthat you signed up for on a whim.&lt;/li&gt;\n&lt;li&gt;Articles you miss get resurfaced repeatedly, so you don't feel like you have to &amp;quot;keep up&amp;quot; with\nanything.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The web app also features a &amp;quot;for you&amp;quot; feed, similar to the daily emails, which lets you read\non-demand. There are pages that list your content chronologically in case you want to read something\nspecific: the recommendation algorithm is there as a default, but it's not the only way to read.\nThere's a &amp;quot;favorites&amp;quot; page which lists articles that you've thumbs-upped.&lt;/p&gt;\n&lt;p&gt;Yakread is monetized through native ads (mostly for newsletters) and a &amp;quot;premium&amp;quot; subscription which\nremoves ads.&lt;/p&gt;\n&lt;h3 id=\"the-code\"&gt;The code&lt;/h3&gt;\n&lt;p&gt;The README has &lt;a href=\"https://github.com/jacobobryant/yakread?tab=readme-ov-file#code-structure\"&gt;a\nsection&lt;/a&gt; describing the\nparts of Yakread's code structure that differ from regular Biff projects. Here are a few high-level\npoints, written without assuming any prior knowledge of Biff.&lt;/p&gt;\n&lt;p&gt;&amp;quot;The algorithm&amp;quot;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;For recommending new articles (i.e. not ones from your own subscriptions or bookmarks), Yakread\nuses Spark MLlib's &lt;a href=\"https://spark.apache.org/docs/latest/mllib-collaborative-filtering.html\"&gt;collaboritive\nfiltering&lt;/a&gt;\nimplementation. There are controls layered on top that bias the results toward articles that have\nbeen recommended a fewer number of times across all users (exploration vs. exploitation).&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Ads are selected via the same collaborative filtering model. The predicted rating for each ad is treated as a\nprobability that the user will click on that ad, then we calculate the expected value of showing\neach ad (i.e. probability of a click multiplied by how much the advertiser is bidding for each\nclick) and charge the advertiser (in the case of a click) via a &lt;a href=\"https://en.wikipedia.org/wiki/Generalized_second-price_auction\"&gt;second-price\nauction&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;The algorithm for selecting articles from your subscriptions and bookmarks is &lt;a href=\"https://github.com/jacobobryant/yakread/blob/b2f0a93a896112479dfaf17fa0ebae765047547a/src/com/yakread/model/recommend.clj\"&gt;a few hundred\nlines&lt;/a&gt;\nof custom code, which e.g.: computes a pair of &amp;quot;affinity&amp;quot; scores (lower bound and\nupper bound) for each of your subscriptions based on your previous interactions; ranks\nsubscriptions based on affinity score, again with controls for exploration vs. exploitation; ranks\narticles based on how recently they were recommended and how recently they were published; figures\nout the right balance between recommending subscription posts and recommending bookmarks.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Everything else:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Yakread is a server-side rendered app that uses &lt;a href=\"https://htmx.org/\"&gt;htmx&lt;/a&gt;. There's nothing too\nfancy going on in the UI (&lt;a href=\"https://yakread.com/advertise\"&gt;the biggest form&lt;/a&gt; in the app has 8\nfields), so I'm keeping it simple.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;It uses &lt;a href=\"https://xtdb.com/\"&gt;XTDB&lt;/a&gt; for the database. You could think of XTDB's immutable\narchitecture kind of like &amp;quot;distributed SQLite.&amp;quot; Queries operate on a local point-in-time snapshot\nof the data, so you can run multiple queries while handling a given request without worrying about\nnetwork latency (pretty helpful for a recommender system).&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;The app's data model is organized via &lt;a href=\"https://pathom3.wsscode.com/\"&gt;Pathom&lt;/a&gt;. I sometimes think of\nPathom as &amp;quot;data-oriented dependency injection.&amp;quot; It gives you the benefit of ORM model objects from\nOOP languages but without having to pass around a database connection. You specify up front what\nentities and fields you want, then Pathom wires up the data in the correct shape for you.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;I use state machines to separate pure application logic from effectful code. Application logic\nreturns data describing the effects it needs to perform (Pathom queries, network requests,\ndatabase transactions, etc), then the machine transitions to other states that perform the\neffects, then results are passed to the next pure logic state, and so on. This makes unit tests\neasy to write since you never have to mock anything or check the results of side effects.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;The tests are largely &lt;a href=\"https://biffweb.com/p/edn-tests/\"&gt;inline snapshot tests&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Yakread currently deployed as a monolith to a single DigitalOcean droplet which handles both web\nrequests and background jobs. If/when the time comes to deploy a separate worker (which probably\nneeds to happen soon...), the same deployment artifact can be ran with a &lt;code&gt;BIFF_PROFILE=worker&lt;/code&gt; env\nvar set.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;I deploy Yakread with &lt;code&gt;rsync&lt;/code&gt;. Even though there's only a single web server, most deploys can be done\nwithout downtime via the REPL: after &lt;code&gt;rsync&lt;/code&gt; finishes, new code is evaluated while the application\nruns. Full restarts typically only happen when new dependencies are added.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Yakread does a lot of email: I use &lt;a href=\"https://github.com/voodoodyne/subethasmtp\"&gt;SubethaSMTP&lt;/a&gt; to\nreceive email newsletters (set an MX record and open up port 25) and\n&lt;a href=\"https://www.mailersend.com/\"&gt;MailerSend&lt;/a&gt; for sending the daily digests.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\"the-theory\"&gt;The theory&lt;/h3&gt;\n&lt;p&gt;I've been interested in recommender systems for a long time, starting with music and then moving\ninto written content. In both domains I've been attracted to the idea of a system that can handle\nmost of the tedious organizational work while only requiring you to do the part that only you, as\nthe human, can do: give feedback on which things you like and don't like. I think there's plenty of\nunrealized potential for recommender systems to help people learn, enjoy life, and coordinate.&lt;/p&gt;\n&lt;p&gt;Recommender systems often get a bad rap, and for good reason: most people's exposure to them comes\nin the form of large companies trying to shove the digital equivalent of potato chips down their\nthroat. However I see that as a problem of business incentives rather than a problem with\nalgorithmic recommendation in general; there aren't any technical barriers to writing algorithms\nthat serve up salad instead of potato chips.&lt;/p&gt;\n&lt;p&gt;So I don't think a mass return to reverse-chronological feeds is the answer: competition is. Ideally\nwe'd have a larger distribution of companies offering recommendation-powered services that had to\ncompete based on the quality of their results. Instead we mostly have a few behemoths that are\noptimized to squeeze every bit of interaction from you that they can, the long-forgotten sanctity of\nyour notifications tab be damned.&lt;/p&gt;\n&lt;p&gt;I hope that Yakread makes the internet a little bit better in that regard. Although I've pretty much\ngiven up on trying to take over the world, I still like the idea of being part of a movement. And\nthere is interesting stuff happening: Bluesky, for instance, has had far more success than I thought\nit would when it was announced back in 2019. The popularity of email newsletters is encouraging.&lt;/p&gt;\n&lt;p&gt;The internet is still young. Maybe the next decade can be a phase of building &lt;a href=\"https://knightcolumbia.org/content/the-case-for-digital-public-infrastructure\"&gt;digital public\ninfrastructure&lt;/a&gt;.&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/yakread-relaunch/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Writing your tests in EDN files</title><id>https://biffweb.com/p/edn-tests/</id><updated>2025-07-19T10:45:00.000Z</updated><content type=\"html\">&lt;p&gt;I've &lt;a href=\"https://biffweb.com/p/structuring-large-codebases/\"&gt;previously written&lt;/a&gt; about my latest\napproach to unit tests (which I have been informed is called &amp;quot;snapshot testing&amp;quot;):&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;[Y]ou define only the input data for your function, and then the expected return value is\ngenerated by calling your function. The expected value is saved to an EDN file and checked into\nsource, at which point you ensure the expected value is, in fact, what you expect. Then going\nforward, the unit test simply checks that what the function returns still matches what‚Äôs in the\nEDN file. If it‚Äôs supposed to change, you regenerate the EDN file and inspect it before\ncommitting.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;I still like that general approach, however my previous implementation of it ended up being a little\ntoo heavy-weight/too reliant on inversion of control. The test runner code had all these things\nbuilt into it for dealing with fixtures, providing a seeded database value, and other concerns.\nWriting new tests ended up requiring a little too much cognitive overhead, and I reverted back to\nmanual testing (via a mix of the REPL and the browser).&lt;/p&gt;\n&lt;p&gt;I have now simplified the approach so that writing tests is basically the same as running code in\nthe REPL, and there's barely anything baked into the test runner itself that you have to remember. I\nput all my tests in EDN files like this (named with the pattern &lt;code&gt;my_namespace_test.edn&lt;/code&gt;):&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;{:require\n [[com.yakread.model.recommend :refer :all]\n  [com.yakread.lib.test :as t]\n  [clojure.data.generators :as gen]],\n :tests\n [{:eval (weight 0), :result 1.0}\n  _\n  {:eval (weight 1), :result 0.9355069850316178}\n  _\n  {:eval (weight 5), :result 0.7165313105737893}\n  ...]}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(&lt;a href=\"https://github.com/jacobobryant/yakread/blob/84a1ed219a7357259bb1625d4f410a63eeef3091/src/com/yakread/model/recommend.clj#L59\"&gt;weight&lt;/a&gt;\nis a simple function for the &lt;a href=\"https://en.wikipedia.org/wiki/Forgetting_curve\"&gt;forgetting curve&lt;/a&gt;,\nwhich I'm using in &lt;a href=\"https://yakread.com/\"&gt;Yakread's&lt;/a&gt; recommendation algorithm.)&lt;/p&gt;\n&lt;p&gt;I only write the &lt;code&gt;:eval&lt;/code&gt; part of each test case. The test runner evaluates that code, adds in the\n&lt;code&gt;:result&lt;/code&gt; part, and &lt;code&gt;pprint&lt;/code&gt;s it all back to the test file. Right now there isn't a concept of\n&amp;quot;passing&amp;quot; or &amp;quot;failing&amp;quot; tests. Instead, when the tests are right, you check them into git; if any\ntest results change, you'll see it in the diff. Then you can decide whether to commit the new\nresults (if the change is expected) or go fix the bug (if it wasn't). If I had CI tests for my\npersonal projects, I'd probably add a flag to have the test runner report any test cases with\nchanged results as failed.&lt;/p&gt;\n&lt;p&gt;In my &lt;code&gt;lib.test&lt;/code&gt; namespace I've added a couple helper functions, such as a &lt;code&gt;t/with-db&lt;/code&gt; function that\npopulates an in-memory &lt;a href=\"https://xtdb.com/\"&gt;XTDB&lt;/a&gt; database value:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;{:require\n [[com.yakread.work.digest :refer :all]\n  [com.yakread.lib.test :as t]\n  [clojure.data.generators :as gen]],\n :tests\n [{:eval\n   (t/with-db\n    [db\n     [{:xt/id &amp;quot;user1&amp;quot;, :user/email &amp;quot;user1@example.com&amp;quot;}\n      {:xt/id &amp;quot;user2&amp;quot;,\n       :user/email &amp;quot;user2@example.com&amp;quot;,\n       :user/digest-last-sent #time/instant &amp;quot;2000-01-01T00:00:00Z&amp;quot;}]]\n    (queue-send-digest\n     {:biff/db db,\n      :biff/now #time/instant &amp;quot;2000-01-01T16:00:01Z&amp;quot;,\n      :biff/queues\n      {:work.digest/send-digest\n       (java.util.concurrent.PriorityBlockingQueue. 11 (fn [a b]))}}\n     :start)),\n   :result\n   {:biff.pipe/next\n    ({:biff.pipe/current :biff.pipe/queue,\n      :biff.pipe.queue/id :work.digest/send-digest,\n      :biff.pipe.queue/job\n      {:user/email &amp;quot;user1@example.com&amp;quot;, :xt/id &amp;quot;user1&amp;quot;}})}}\n  ...]}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(&lt;a href=\"https://github.com/jacobobryant/yakread/blob/84a1ed219a7357259bb1625d4f410a63eeef3091/src/com/yakread/work/digest.clj#L41\"&gt;queue-send-digest&lt;/a&gt;\nreturns a list of users who need to be sent an email digest of their RSS subscriptions and other\ncontent.)&lt;/p&gt;\n&lt;p&gt;I like this approach a lot more than the old one: you just write regular code, with test helper\nfunctions for seeded databases or whatever if you need them. It's been pretty convenient to write my\n&amp;quot;REPL&amp;quot; code in these &lt;code&gt;_test.edn&lt;/code&gt; files and then have the results auto-update as I develop the\nfunction under test.&lt;/p&gt;\n&lt;p&gt;There are a couple other doodads: if the code in &lt;code&gt;:eval&lt;/code&gt; throws an exception, the test runner writes\nthe exception as data into the test case, albeit under an &lt;code&gt;:ex&lt;/code&gt; key instead of under &lt;code&gt;:results&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;{:require\n [[com.yakread.model.recommend :refer :all]\n  [com.yakread.lib.test :as t]\n  [clojure.data.generators :as gen]],\n :tests\n [{:eval (weight 0)\n   :ex\n   {:cause &amp;quot;oh no&amp;quot;,\n    :data {:it's &amp;quot;sluggo&amp;quot;},\n    :via\n    [{:type clojure.lang.ExceptionInfo,\n      :message &amp;quot;oh no&amp;quot;,\n      :data {:it's &amp;quot;sluggo&amp;quot;},\n      :at\n      [com.yakread.model.recommend$eval75461$weight__75462\n       invoke\n       &amp;quot;recommend.clj&amp;quot;\n       60]}],\n    :trace\n    [[com.yakread.model.recommend$eval75461$weight__75462\n      invoke\n      &amp;quot;recommend.clj&amp;quot;\n      60]\n     [tmp418706$eval83727 invokeStatic &amp;quot;NO_SOURCE_FILE&amp;quot; 0]\n     [tmp418706$eval83727 invoke &amp;quot;NO_SOURCE_FILE&amp;quot; -1]\n     [clojure.lang.Compiler eval &amp;quot;Compiler.java&amp;quot; 7700]\n     [clojure.lang.Compiler eval &amp;quot;Compiler.java&amp;quot; 7655]\n     [clojure.core$eval invokeStatic &amp;quot;core.clj&amp;quot; 3232]\n     [clojure.core$eval invoke &amp;quot;core.clj&amp;quot; 3228]]}}\n  ...]}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The stack trace gets truncated so it only contains frames from your &lt;code&gt;:eval&lt;/code&gt; code (mostly‚ÄîI\ncould truncate it a little more).&lt;/p&gt;\n&lt;p&gt;I also capture any &lt;code&gt;tap&amp;gt;&lt;/code&gt;'d values and insert those into the test case, whether or not there was an\nexception. It's handy for inspecting intermediate values:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;:tests\n[{:eval (weight 1),\n  :result 0.9355069850316178,\n  :tapped [&amp;quot;hello there&amp;quot; &amp;quot;exponent: -1/15&amp;quot;]}\n  ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And that's it. If you want to try this out, you can copy\n&lt;a href=\"https://github.com/jacobobryant/yakread/blob/b5cb3889fa4f08a77c51cc209d0e990bdf3cc01c/test/com/yakread/lib/test.clj#L83\"&gt;run-examples!&lt;/a&gt;\n(the test runner function) into your own project. It searches your classpath for any files ending in\n&lt;code&gt;_test.edn&lt;/code&gt; and runs the tests therein. I call it from a file watcher (Biff's &lt;code&gt;on-save&lt;/code&gt; function) so\nyour test results get updated whenever you save any file in the project.&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/edn-tests/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">EDN-infused plain html forms</title><id>https://biffweb.com/p/edn-html-forms/</id><updated>2025-06-20T19:36:00.000Z</updated><content type=\"html\">&lt;p&gt;Merry solstice. After about a year, I'm roughly 80% done with the\n&lt;a href=\"https://github.com/jacobobryant/yakread\"&gt;Yakread&lt;/a&gt; rewrite. Now all that's left is the remaining\n80%. &lt;a href=\"https://biffweb.com/p/structuring-large-codebases/\"&gt;My last post&lt;/a&gt; is still a good explanation\nof the new Biff things I've been hacking on as part of that. Over the past couple weeks I've also\nbeen thinking about how to do forms.&lt;/p&gt;\n&lt;p&gt;So far Biff hasn't provided anything special for forms: if you need an email address, you do\n&lt;code&gt;[:input {:name &amp;quot;email&amp;quot;} ...]&lt;/code&gt;, you get the value as a string from &lt;code&gt;(-&amp;gt; request :params :email)&lt;/code&gt;,\nyou parse it if needed (not needed in this case), then you stick it in a map like &lt;code&gt;{:user/email email, ...}&lt;/code&gt; or whatever. Works fine for small forms; no need to over-complicate things.&lt;/p&gt;\n&lt;p&gt;But what if you have form with 50 fields? It would be nice if we could get EDN from the frontend,\ne.g. &lt;code&gt;{:user/email &amp;quot;abc@example.com&amp;quot;, :user/age 666}&lt;/code&gt; instead of &lt;code&gt;{:email &amp;quot;abc@example.com&amp;quot;, :age &amp;quot;666&amp;quot;}&lt;/code&gt;. Same as you get if you're doing a cljs frontend instead of htmx. htmx users deserve nice\nthings too!&lt;/p&gt;\n&lt;p&gt;I've started rendering my form fields like &lt;code&gt;[:input {:name (pr-str :user/email)} ...]&lt;/code&gt; (turns out\n&lt;code&gt;:name&lt;/code&gt; will accept just about anything) and then using a\n&lt;a href=\"https://github.com/jacobobryant/yakread/blob/9052fe12b7df9bdb944d6998e37432905b1ec229/src/com/yakread/lib/form.clj#L54\"&gt;wrap-parse-form&lt;/a&gt;\nmiddleware to parse the requests. That function attempts to parse each key in the form params with\n&lt;code&gt;edn/read-string&lt;/code&gt; (&lt;a href=\"https://github.com/tonsky/fast-edn\"&gt;fast-edn&lt;/a&gt;, actually), skipping keys that\nfail. For each parsed key, we then check your Biff app's Malli schema to see if that key is defined\nand what its type is. We use the type to figure out how to parse the form value. There are default\nparse functions for a few common types (&lt;code&gt;int&lt;/code&gt; is &lt;code&gt;Long/parseLong&lt;/code&gt;, &lt;code&gt;:uuid&lt;/code&gt; is &lt;code&gt;parse-uuid&lt;/code&gt;, etc).\nFor other types, you can define a custom form parser in your schema, for example:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(def schema\n  {::cents [:int {:biff.form/parser\n                  #(-&amp;gt; %\n                       (Float/parseFloat)\n                       (* 100)\n                       (Math/Round))}]\n   :ad [:map {:closed true}\n        [:ad/budget ::cents]\n        ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now if I have a form field like &lt;code&gt;[:input {:name (pr-str :ad/budget)} ...]&lt;/code&gt; and the user types in\n&lt;code&gt;12.34&lt;/code&gt;, on the backend I'll get &lt;code&gt;{:ad/budget 1234, ...}&lt;/code&gt; automagically.&lt;/p&gt;\n&lt;p&gt;The form data isn't quite self-describing like EDN is: it relies on schema defined somewhere outside\nthe form. I started out doing stuff like &lt;code&gt;[:input {:name (pr-str {:field :user/favorite-number, :type :int})} ...]&lt;/code&gt; (seriously, you really can put anything in &lt;code&gt;:name&lt;/code&gt;), but since I'm writing this\nmiddleware for Biff apps specifically, I didn't feel like that approach was adding much value. And\nI'm all about value.&lt;/p&gt;\n&lt;p&gt;What about forms with multiple entities? If your &lt;code&gt;:name&lt;/code&gt; value is a vector like &lt;code&gt;(pr-str [:user :user/email])&lt;/code&gt;, then &lt;code&gt;wrap-parse-form&lt;/code&gt; will do an &lt;code&gt;(assoc-in params [:user :user/email] ...)&lt;/code&gt;. I\ndon't at the moment have any special support for arrays of things, but you can do &lt;code&gt;:name (pr-str [:users 3 :user/email])&lt;/code&gt; and then you'll get &lt;code&gt;{:users {3 {:user/email ...}}}&lt;/code&gt; in the request.&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;&lt;strong&gt;Other Biff news&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Remaining things in the Yakread TODO list include finishing the ad system, adding premium plans,\nprecomputing some recommendation models so that page loads are faster, and setting up email digests\nof your subscriptions. How long could that take? Surely not long! Oh, and then I just need to\nmigrate all the users over from the &lt;a href=\"https://yakread.com\"&gt;currently-in-production&lt;/a&gt; Yakread as well\nas &lt;a href=\"https://thesample.ai\"&gt;another similar app&lt;/a&gt; that stopped being profitable last year... but yes,\ncertainly not long.&lt;/p&gt;\n&lt;p&gt;Once that's humming along and my monthly side project operational costs are back in the double\ndigits, it'll be time for a much needed Biff release. I'll extract some of the stuff from Yakread\nand package it up real nice, and then go through some &lt;a href=\"https://github.com/jacobobryant/biff/issues/217\"&gt;\nmaintenance&lt;/a&gt; tasks that have been... festering,\nshall we say. And &lt;em&gt;then&lt;/em&gt; it's time for...&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;x·¥õ·¥Ö ô ·¥†·¥á Äs…™·¥è…¥ 2&lt;/strong&gt;: at last. Everyone's favorite 4-letter immutable database is &lt;a href=\"https://xtdb.com/blog/launching-xtdb-v2\"&gt;out of\nbeta&lt;/a&gt;. Which means it's really time to get Biff on it. I\nfigure Yakread, once the rewrite is done, will make a nice open-source example of porting a\nnontrivial app from XTDB v1 to v2. So expect a big Biff release with migration guide and all that.\nHopefully by the end of the year üò¨. Maybe I could even look into integrating XTDB with Rama.&lt;/p&gt;\n&lt;p&gt;Until we meet again, perhaps at the equinox. Or at the conj. I've got my ticket already.&lt;/p&gt;\n&lt;p&gt;Two free t-shirt ideas:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&amp;quot;(got? :lisp)&amp;quot; -- styled to look like those &amp;quot;got milk?&amp;quot; fridge magnets.&lt;/li&gt;\n&lt;li&gt;&amp;quot;Breaking changes are for the weak&amp;quot; -- not sure how to style it, but this t-shirt definitely needs\nto exist.&lt;/li&gt;\n&lt;/ul&gt;\n</content><link href=\"https://biffweb.com/p/edn-html-forms/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Structuring large Clojure codebases with Biff</title><id>https://biffweb.com/p/structuring-large-codebases/</id><updated>2025-01-28T20:15:00.000Z</updated><content type=\"html\">&lt;!-- email\n\nMy Biff work over the past six months or so has been focused on rewriting\n[Yakread](https://yakread.com) from scratch and implementing new framework\nfeatures along the way to make the v2 app more maintainable and performant. This\nis a fairly large project, and I won't be officially releasing any new Biff\nfeatures until the rewrite is done (I want to give myself a chance to kick the\ntires first). In the interim, I briefly tried making some informal videos to\ndocument my progress:\n\n- [Yakread schema](https://biffweb.com/p/yakread-schema/)\n- [Yakread + Pathom](https://biffweb.com/p/yakread-pathom/)\n\nBut after two videos I decided that I'd rather spend my time writing 3 or 4\nhigh-quality articles per year than making a couple mediocre videos per month.\nI'm also trying to write said articles with both Clojure and non-Clojure\naudiences in mind (gotta get that HN karma).\n\nSo here's the first article. You can also [read it on the web](https://biffweb.com/p/structuring-large-codebases/).\n\n&amp;ndash;[Jacob](https://obryant.dev)\n\n---\n\n--&gt;\n&lt;p&gt;I've been making some progress on rewriting &lt;a href=\"https://yakread.com/\"&gt;Yakread&lt;/a&gt; (a\nfancy reading app) from ~scratch and open-sourcing it in the process. Along the\nway I'm experimenting with potential new features for\n&lt;a href=\"https://biffweb.com/\"&gt;Biff&lt;/a&gt;, my Clojure web framework, which Yakread is built\nwith. In particular I'm working on approaches for keeping Biff apps more\nmanageable as the codebase grows: the original Yakread codebase was about 10k\nlines and was already getting pretty crufty. I've also learned some things from\ncontributing to our ~85k-line Clojure codebase at work.&lt;/p&gt;\n&lt;p&gt;I thought it'd be worth going over the main new architectural approaches in\nYakread for anyone interested in poking around the code/as a preview of what to\nexpect in Biff later on. The &lt;a href=\"https://github.com/jacobobryant/yakread\"&gt;open-source\nrepo&lt;/a&gt; has only a sliver of the\nproduction app's functionality so far, but it has examples of all the\napproaches described below.&lt;/p&gt;\n&lt;h2 id=\"materialized-views\"&gt;Materialized views&lt;/h2&gt;\n&lt;p&gt;&amp;quot;Old Yakread&amp;quot; has a lot of slow queries. For example, loading the subscriptions\npage on my account takes more than 10 seconds: for each of my hundreds of\nsubscriptions, it has to run a query to figure out how many unread posts there\nare and when the most recent post was published. This is currently done the dumb\nway, i.e. Yakread queries for every single post and then computes the aggregate\ndata.&lt;/p&gt;\n&lt;p&gt;The traditional way to solve this would be to denormalize the data model (add\nfields for ‚Äú# unread items‚Äù and ‚Äúlast published at‚Äù to the subscription model)\nand keep it up to date manually (update those fields whenever a new post is\npublished, whenever the user reads a post, etc). However, &lt;a href=\"https://lironshapira.medium.com/data-denormalization-is-broken-7b697352f405\"&gt;this approach can get\nout of\nhand&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;I‚Äôve addressed this in a cleaner way by &lt;a href=\"https://github.com/jacobobryant/biff/blob/indexes/src/com/biffweb/impl/index.clj\"&gt;implementing materialized\nviews&lt;/a&gt;\nfor XTDB. I store them in a dedicated RocksDB instance. For each piece of\ndenormalized data you need, &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/model/subscription.clj#L88\"&gt;you define a pure &amp;quot;denormalizer&amp;quot;\nfunction&lt;/a&gt;*\nwhich takes in an item from XTDB‚Äôs transaction log along with the current\nRocksDB state and returns a map of key-value pairs that will be written back to\nRocksDB. Biff handles everything else: setting up RocksDB, running your\ndenormalizer functions whenever there‚Äôs a new XTDB transaction, and providing a\nRocksDB snapshot for querying that‚Äôs consistent with your current XTDB snapshot\n(we retain XTDB's database-as-a-value semantics).&lt;/p&gt;\n&lt;p&gt;*Still deciding on the name... the codebase calls them &amp;quot;indexer&amp;quot; functions\ncurrently, but I decided &amp;quot;materialized views&amp;quot; are a clearer/more accurate term\nthan &amp;quot;indexes.&amp;quot;&lt;/p&gt;\n&lt;p&gt;This is a lower-level approach than something like\n&lt;a href=\"https://materialize.com/\"&gt;Materialize&lt;/a&gt;, which lets you write regular SQL\nqueries instead of defining these denormalizer functions (i.e. you‚Äôre defining a\nfunction of &lt;code&gt;current DB state -&amp;gt; materialized view&lt;/code&gt; instead of &lt;code&gt;new transaction, current materialized view -&amp;gt; new materialized view&lt;/code&gt;). However,\nwhen I experimented with Materialize several years ago I found that its memory\noverhead made it untenable for my use case. I‚Äôm sure it‚Äôs much better for, say,\naggregating metrics from large real-time systems, even if it sadly didn‚Äôt work\nout for the simplify-random-guy‚Äôs-RSS-reader use case. (I‚Äôd also like to look\ninto other things in this space like &lt;a href=\"https://redplanetlabs.com/\"&gt;Rama&lt;/a&gt; and\n&lt;a href=\"https://github.com/feldera/feldera\"&gt;Feldera&lt;/a&gt;).&lt;/p&gt;\n&lt;p&gt;Writing the &lt;a href=\"https://www.google.com/search?q=incremental+view+maintenance\"&gt;incremental view\nmaintenance&lt;/a&gt; logic\nby hand is somewhat tedious, but the testing approach I'm using makes it really\nnot bad. I‚Äôve &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/test/com/yakread/lib/test.clj#L180\"&gt;written\ncode&lt;/a&gt;\nwith &lt;a href=\"https://github.com/vouch-opensource/fugato\"&gt;Fugato&lt;/a&gt; that can take the\ndatabase schema for your app and generate test data for use with test.check\n(Clojure‚Äôs property-based testing library). All you have to do is write an\n‚Äúoracle‚Äù function that takes a database snapshot and computes what the\nmaterialized view should look like for that snapshot. e.g. for the ‚Äúsubscription\nlast published at‚Äù materialized view, &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/test/com/yakread/model/subscription_test.clj#L56\"&gt;the oracle\nfunction&lt;/a&gt;\nsimply gets all the posts for each subscription and then finds the one with the\nlatest published-at date. Then the testing code ensures that the materialized\nview computed by your denormalizer function matches.&lt;/p&gt;\n&lt;h2 id=\"separating-application-logic-from-effects\"&gt;Separating application logic from effects&lt;/h2&gt;\n&lt;p&gt;100% of the application code in &amp;quot;New Yakread&amp;quot; is pure. The unit tests never have\nto set up mocks or check the results of side effects. Every unit test has the\nform ‚Äúpass some data to this pure function and make sure the output matches this\nconstant.‚Äù&lt;/p&gt;\n&lt;p&gt;I accomplish this by turning each function with application logic into &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/app/subscriptions/add.clj#L176\"&gt;a little\nstate\nmachine&lt;/a&gt;,\nwhere each state is either a unit of pure computation (app logic) or an effect\nhandler. Whenever the pure app logic needs to do something effectful, like run\nan HTTP request or save something to the database, it returns &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/app/subscriptions/add.clj#L179\"&gt;some\ndata&lt;/a&gt;\ndescribing the effect, which causes the machine to transition to an effectful\nstate.&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/lib/pipeline.clj#L52\"&gt;These effectful\nstates&lt;/a&gt;\nperform the effects and then transition back to your pure application logic.\nThey're centralized in one spot in your app, and they‚Äôre kept as dumb as\npossible: take some input data, do the effect, return the output.&lt;/p&gt;\n&lt;p&gt;For testing, each pure app logic state can be called individually without\nrunning the whole machine. This facilitates an approach to unit testing that\nI‚Äôve been enjoying quite a bit: you define only &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/test/com/yakread/app/subscriptions/add_test.clj#L26\"&gt;the input\ndata&lt;/a&gt;\nfor your function, and then the &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/test/com/yakread/app/subscriptions/add_test/examples.edn#L17\"&gt;expected return\nvalue&lt;/a&gt;\nis generated by calling your function. The expected value is saved to an EDN\nfile and checked into source, at which point you ensure the expected value is,\nin fact, what you expect. Then going forward, the unit test simply checks that\nwhat the function returns still matches what‚Äôs in the EDN file. If it‚Äôs supposed\nto change, you regenerate the EDN file and inspect it before committing.&lt;/p&gt;\n&lt;p&gt;This is so convenient that for once I‚Äôve actually been writing unit tests as I\ndevelop code instead of testing manually e.g. via the browser and then (maybe)\nwriting tests after the fact. Thanks to &lt;a href=\"https://github.com/djblue\"&gt;Chris\nBadahdah&lt;/a&gt; for telling me about this approach.&lt;/p&gt;\n&lt;p&gt;This also has benefits for observability: the state-machine-executor code is &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/lib/pipeline.clj#L35\"&gt;a\nconvenient\nplace&lt;/a&gt;\nto put tracing and exception handling code. Whenever your app logic throws\nan exception, you'll be guaranteed to have the necessary input data to reproduce\nit, without having to add logging yourself.&lt;/p&gt;\n&lt;h2 id=\"pathom\"&gt;Pathom&lt;/h2&gt;\n&lt;p&gt;The final big change I‚Äôve made is that the codebase is now split up into a bunch\nof &lt;a href=\"https://pathom3.wsscode.com/\"&gt;Pathom&lt;/a&gt; resolvers. I've also written a few\nPathom/Biff helper functions, such as &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/util/biff_staging.clj#L50\"&gt;this\none&lt;/a&gt;\nwhich auto-generates resolvers for your XTDB entities.&lt;/p&gt;\n&lt;p&gt;It took me a while to ‚Äúget‚Äù Pathom, but now I‚Äôm a big fan. My latest attempt at\nexplaining it is to make a comparison with OOP. It's standard to have classes\nfor your domain entities (&lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Product&lt;/code&gt;, whatever) which have some fields\nthat correspond to columns in the corresponding database record and some\nfields/methods that return derived data. A common example would be having\ncolumns for &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt; in the database, and then the class\ncould also have a derived &lt;code&gt;full_name&lt;/code&gt; method which combines the two.&lt;/p&gt;\n&lt;p&gt;Pathom lets you do a similar thing: you define &amp;quot;resolvers&amp;quot; for each of the\nfields in your domain; some resolvers fetch stuff from the database, while other\nresolvers return derived data built on top of those values.&lt;/p&gt;\n&lt;p&gt;The big difference between Pathom and OOP-style &amp;quot;model code&amp;quot; (not sure what to\ncall it) is that In the OOP style, your model code and app code gets\ninterleaved. With Pathom, you first submit a query and get the results as a\nplain data structure, then you pass the data structure to your application code.\nLike the effects stuff in the previous section, this helps your application code\nstay pure.&lt;/p&gt;\n&lt;p&gt;I use Pathom heavily to separate my model and view code. Each GET request\nhandler &lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/app/subscriptions.clj#L70\"&gt;defines a Pathom\nquery&lt;/a&gt;,\nand I have middleware which runs the query and passes the results to the handler\nfunction. Those handler functions thus never need to include code at the top\nlevel for querying the database, fetching things from S3, or augmenting database\nrecords with custom business logic: that‚Äôs all done by Pathom resolvers in other\nnamespaces. This makes the request handlers easier to write and understand.&lt;/p&gt;\n&lt;p&gt;I also have resolvers that return UI fragments. For example, the subscriptions\npage needs to render a list of all your RSS and newsletter subscriptions. I have\n&lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/app/subscriptions.clj#L21\"&gt;a\nresolver&lt;/a&gt;\nwhich renders an individual subscription card (which includes things like the\nsubscription title and the number of unread posts). The parent\nresolver‚Äîthe one that renders the entire list of\nsubscriptions‚Äîdoesn‚Äôt need to specify all the data needed to render each\ncard. It just queries for a list of ‚Äú&lt;a href=\"https://github.com/jacobobryant/yakread/blob/cbb46eb8454a78f78b82fcf2cc33cf2bbb56643b/src/com/yakread/app/subscriptions.clj#L72\"&gt;subscription\ncards&lt;/a&gt;,‚Äù\nwhich again helps to keep each individual resolver small and easy to understand.&lt;/p&gt;\n&lt;p&gt;This approach is conceptually similar to what\n&lt;a href=\"https://fulcro.fulcrologic.com/\"&gt;Fulcro&lt;/a&gt; does: each UI component declares its\nown query. The difference is that Fulcro is a SPA framework; Fulcro includes a\nbunch of plumbing so that you can extend this programming model to the frontend.\nSince Yakread is server-side rendered with htmx, it just uses plain backend\nPathom resolvers for everything.&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;The Yakread rewrite has a long ways to go. However I think the\nexperimentation phase may be largely over: the framework features I‚Äôve described\nabove are all in place; now I just need to bang out the rest of the app. Once\nthat's done, I'll start extracting various parts out of Yakread and releasing\nthem as part of Biff.&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/structuring-large-codebases/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Yakread + Pathom [video]</title><id>https://biffweb.com/p/yakread-pathom/</id><updated>2024-12-21T13:30:00.000Z</updated><content type=\"html\">&lt;div style=\"padding:56.25% 0 0 0;position:relative;\"&gt;&lt;iframe src=\"https://player.vimeo.com/video/1041441592?badge=0&amp;amp;autopause=0&amp;amp;player_id=0&amp;amp;app_id=58479\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture; clipboard-write\" style=\"position:absolute;top:0;left:0;width:100%;height:100%;\" title=\"Yakread + Pathom\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script src=\"https://player.vimeo.com/api/player.js\"&gt;&lt;/script&gt;\n&lt;br&gt;\n&lt;p&gt;An explanation of how I'm using Pathom to keep Yakread's code organized. Also some slight schema modifications.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/jacobobryant/yakread/commit/f52c9d861b4bb89beed64ec69a59563d2e5b5be6\"&gt;Code&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</content><link href=\"https://biffweb.com/p/yakread-pathom/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Yakread schema [video]</title><id>https://biffweb.com/p/yakread-schema/</id><updated>2024-12-07T10:30:00.000Z</updated><content type=\"html\">&lt;div style=\"padding:56.25% 0 0 0;position:relative;\"&gt;&lt;iframe src=\"https://player.vimeo.com/video/1037076545?badge=0&amp;amp;autopause=0&amp;amp;player_id=0&amp;amp;app_id=58479\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture; clipboard-write\" style=\"position:absolute;top:0;left:0;width:100%;height:100%;\" title=\"Yakread schema\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script src=\"https://player.vimeo.com/api/player.js\"&gt;&lt;/script&gt;\n&lt;br&gt;\n&lt;p&gt;I've started open-sourcing Yakread. I'm going to try publishing videos about it along the way. This first video describes Yakread's schema. The production quality here is a little low... next time I'll try disabling dark mode and making the text larger.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://yakread.com\"&gt;Yakread&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/jacobobryant/yakread\"&gt;repository&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://github.com/jacobobryant/yakread/blob/master/src/com/yakread/model/schema.clj\"&gt;schema.clj&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</content><link href=\"https://biffweb.com/p/yakread-schema/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Removing effects from business logic</title><id>https://biffweb.com/p/removing-effects/</id><updated>2024-10-05T19:15:00.000Z</updated><content type=\"html\">&lt;p&gt;This is a thing (state machine? effects-processing pipeline?) I'm trying out to keep effectful code separate from\nbusiness logic, to make testing easier. It's partially inspired by re-frame's event handling. The idea isn't new, but\nI'd never actually done it for my own code until now. I'd be curious to hear what other things people have done in this\nvein. I like this more than the typical approach of just mocking out the effectful bits.&lt;/p&gt;\n&lt;p&gt;I was working on the following function, which is the HTTP request handler for a &amp;quot;subscribe to RSS feed&amp;quot; button. You\nenter a URL into a form, then this handler:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;Fetches the URL and figures out if it goes directly to an RSS feed &lt;em&gt;or&lt;/em&gt; if it goes to a page that has an RSS feed(s)\nin its metadata.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;If there aren't any feeds, show an error message. Otherwise, save the feeds to the database and redirect to the\nuser's subscriptions page.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(def rss-route\n  [&amp;quot;/dev/subscriptions/add/rss&amp;quot;\n   {:name :app.subscriptions.add/rss\n    :post\n    (fn [{:keys [session\n                 params]\n          :as ctx}]\n      (let [url (lib.rss/fix-url (:url params))\n            http-response (http/get url {&amp;quot;User-Agent&amp;quot; &amp;quot;https://yakread.com&amp;quot;})\n            feed-urls (-&amp;gt;&amp;gt; (lib.rss/parse-urls (assoc http-response :url url))\n                           (mapv :url)\n                           (take 20)\n                           vec)]\n        (if (empty? feed-urls)\n          {:status                     303\n           :biff.response/route-name   :app.subscriptions.add/page\n           :biff.response/route-params {:error &amp;quot;invalid-rss-feed&amp;quot;}}\n          (do\n            (biff/submit-tx ctx\n              (for [url feed-urls]\n                {:db/doc-type :conn/rss\n                 :db.op/upsert {:conn/user (:uid session)\n                                :conn.rss/url url}\n                 :conn.rss/subscribed-at :db/now}))\n            {:status                     303\n             :biff.response/route-name   :app.subscriptions/page\n             :biff.response/route-params {:added-feeds (count feed-urls)}}))))}])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(I have other middleware that takes the &lt;code&gt;:biff.response/*&lt;/code&gt; values and converts them to &lt;code&gt;:headers {&amp;quot;location&amp;quot; ...}&lt;/code&gt;.)&lt;/p&gt;\n&lt;p&gt;This handler has two effects: first it it calls &lt;code&gt;clj-http.client/get&lt;/code&gt; on the URL that the user submitted; second, it\ncalls &lt;code&gt;com.biffweb/submit-tx&lt;/code&gt; if it gets a valid RSS url(s).&lt;/p&gt;\n&lt;p&gt;And here is the purified version of that handler, which I'll explain in a moment:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(def rss-route\n  [&amp;quot;/dev/subscriptions/add/rss&amp;quot;\n   {:name :app.subscriptions.add/rss\n    :post\n    (fn [{:keys [session\n                 params\n                 biff.chain/state]\n          :as ctx}]\n      (case state\n        nil\n        {:biff.chain/queue      [:biff.chain/http ::add-urls]\n         :biff.chain.http/input {:url     (lib.rss/fix-url (:url params))\n                                 :method  :get\n                                 :headers {&amp;quot;User-Agent&amp;quot; &amp;quot;https://yakread.com/&amp;quot;}}}\n\n        ::add-urls\n        (let [feed-urls (-&amp;gt;&amp;gt; (lib.rss/parse-urls (:biff.chain.http/output ctx))\n                             (mapv :url)\n                             (take 20)\n                             vec)]\n          (if (empty? feed-urls)\n            {:status                     303\n             :biff.response/route-name   :app.subscriptions.add/page\n             :biff.response/route-params {:error &amp;quot;invalid-rss-feed&amp;quot;}}\n            {:biff.chain/queue    [:biff.chain/tx ::success]\n             :biff.chain.tx/input (vec\n                                   (for [url feed-urls]\n                                     {:db/doc-type :conn/rss\n                                      :db.op/upsert {:conn/user (:uid session)\n                                                     :conn.rss/url url}\n                                      :conn.rss/subscribed-at :db/now}))\n             ::feed-urls feed-urls}))\n\n        ::success\n        {:status                     303\n         :biff.response/route-name   :app.subscriptions/page\n         :biff.response/route-params {:added-feeds (count (::feed-urls ctx))}}))}])\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The handler is meant to be called multiple times by some sort of orchestrator (I'll get to that in a minute). Every time\nthe original function would have performed an effect, this function instead returns some data that describes the effect.\nThe orchestrator runs the effect and then passes the effect's output back to the handler function.&lt;/p&gt;\n&lt;p&gt;The handler uses the value of &lt;code&gt;:biff.chain/state&lt;/code&gt; to know which &amp;quot;segment&amp;quot; of the business logic is being executed\ncurrently, and &lt;code&gt;:biff.chain/queue&lt;/code&gt; tells the orchestrator which segments/effects should happen next. The first time the\nfunction is called, &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;; i.e. we use that as the start state (I could've set it to something like\n&lt;code&gt;:biff.chain/start&lt;/code&gt;, but eh).&lt;/p&gt;\n&lt;p&gt;Our effects code is stored in a &lt;code&gt;lib.chain/globals&lt;/code&gt; map which is shared across the codebase:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(ns com.yakread.lib.chain\n  (:require [clj-http.client :as http]\n            [com.biffweb :as biff]))\n\n...\n\n(def globals\n  {:biff.chain/http\n   (fn [{:keys [biff.chain.http/input] :as ctx}]\n     (assoc ctx :biff.chain.http/output (-&amp;gt; (http/request input)\n                                            (assoc :url (:url input))\n                                            (dissoc :http-client))))\n\n   :biff.chain/tx\n   (fn [{:keys [biff.chain.tx/input] :as ctx}]\n     (assoc ctx :biff.chain.tx/output (biff/submit-tx ctx input)))})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It's as dumb as possible: take some input, do the effect, return the output. I wrap the functions so that the input and\noutput goes under namespaced keys.&lt;/p&gt;\n&lt;p&gt;Going back to the handler function, the chain of states will look like this in the success case:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; -&amp;gt; &lt;code&gt;:biff.chain/http&lt;/code&gt; -&amp;gt; &lt;code&gt;::add-urls&lt;/code&gt; -&amp;gt; &lt;code&gt;:biff.chain/tx&lt;/code&gt; -&amp;gt; &lt;code&gt;::success&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;And it'll look like this in the failure case:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; -&amp;gt; &lt;code&gt;:biff.chain/http&lt;/code&gt; -&amp;gt; &lt;code&gt;::add-urls&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;The orchestrator gets the function associated with each state and calls them in order, taking the return value of each\nfunction and passing it to the next.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(defn orchestrate [{:keys [biff.chain/globals] :as ctx} f]\n  (loop [{[state &amp;amp; remaining] :biff.chain/queue :as result} (f ctx)]\n    (if-not state\n      result\n      (recur ((get globals state f)\n              (merge ctx result {:biff.chain/state state\n                                 :biff.chain/queue remaining}))))))\n\n(defn wrap-chain [handler]\n  (fn [ctx]\n    (orchestrate ctx handler)))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;I apply the &lt;code&gt;wrap-chain&lt;/code&gt; middleware to all my handlers. Since the &amp;quot;non-chain&amp;quot; handlers don't return &lt;code&gt;:biff.chain/queue&lt;/code&gt;,\nthey work the same as if they were called directly.&lt;/p&gt;\n&lt;p&gt;Testing is now really easy. Just a bunch of plain function calls; no need to set up e.g. a mock database or anything.\nFor example:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(deftest rss-route\n  (let [[_ {:keys [post]}] sut/rss-route]\n    (is (= {:biff.chain/queue\n            [:biff.chain/http :com.yakread.app.subscriptions.add/add-urls],\n            :biff.chain.http/input\n            {:url &amp;quot;https://example.com&amp;quot;,\n             :method :get,\n             :headers {&amp;quot;User-Agent&amp;quot; &amp;quot;https://yakread.com/&amp;quot;}}}\n           (post {:params {:url &amp;quot;example.com&amp;quot;}})))\n    ...))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For the parts of the handler that depend on effect output, I wrote a function that generates the fixtures. I\ncall it manually and check the results into source control. Then tests can use the &lt;code&gt;read-fixtures&lt;/code&gt; function:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(defn write-fixtures! []\n  (let [{:biff.chain/keys [http]} (:biff.chain/globals main/initial-system)\n        http-get (fn [url]\n                   (http {:biff.chain.http/input {:url url\n                                                  :method :get\n                                                  :headers {&amp;quot;User-Agent&amp;quot; &amp;quot;https://yakread.com&amp;quot;}}}))]\n    (with-open [o (io/writer &amp;quot;test/com/yakread/app/subscriptions/add_test/fixtures.edn&amp;quot;)]\n      (pprint\n       {:example-com          (http-get &amp;quot;https://example.com&amp;quot;)\n        :obryant-dev          (http-get &amp;quot;https://obryant.dev&amp;quot;)\n        :obryant-dev-feed-xml (http-get &amp;quot;https://obryant.dev/feed.xml&amp;quot;)}\n       o))))\n\n(defn read-fixtures []\n  (edn/read-string (slurp (io/resource &amp;quot;com/yakread/app/subscriptions/add_test/fixtures.edn&amp;quot;))))\n\n...\n\n(deftest rss-route\n  (let [[_ {:keys [post]}] sut/rss-route\n        {:keys [example-com\n                obryant-dev\n                obryant-dev-feed-xml]} (read-fixtures)]\n    ...\n    (is (= {:biff.chain/queue\n            [:biff.chain/tx :com.yakread.app.subscriptions.add/success],\n            :biff.chain.tx/input\n            [{:db/doc-type :conn/rss,\n              :db.op/upsert\n              {:conn/user 1, :conn.rss/url &amp;quot;https://obryant.dev/feed.xml&amp;quot;},\n              :conn.rss/subscribed-at :db/now}],\n            :com.yakread.app.subscriptions.add/feed-urls\n            [&amp;quot;https://obryant.dev/feed.xml&amp;quot;]}\n           (post (merge {:biff.chain/state ::sut/add-urls\n                         :session {:uid 1}}\n                        obryant-dev))))))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;write-fixtures!&lt;/code&gt; calls the functions from &lt;code&gt;:biff.chain/globals&lt;/code&gt;, e.g. instead of calling &lt;code&gt;clj-http.client/get&lt;/code&gt;\ndirectly, to ensure the fixtures match what the effect code will produce. Whenever I update the effect code, I can call\n&lt;code&gt;write-fixtures!&lt;/code&gt; again and make sure the tests still pass.&lt;/p&gt;\n&lt;p&gt;Of course you don't have to write tests that are all of the form &lt;code&gt;(is (= &amp;lt;constant&amp;gt; (my-function ...)))&lt;/code&gt;; you could do\nfancier things too like property-based testing. Or you could pass in a &lt;code&gt;:biff.chain/globals&lt;/code&gt; map that has mocked effects\nso you can write integration tests in the imperative style while keeping your unit tests in the functional style.&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/removing-effects/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">RocksDB indexes are done, open-sourcing Yakread next</title><id>https://biffweb.com/p/rocksdb-indexes-yakread/</id><updated>2024-10-05T19:15:00.000Z</updated><content type=\"html\">&lt;p&gt;&lt;a href=\"https://biffweb.com/p/indexes-2/\"&gt;Last time&lt;/a&gt; on &lt;em&gt;Biff: The Newsletter&lt;/em&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;I've &lt;a href=\"https://gist.github.com/jacobobryant/2afa53e33c5d658de79d431c30554521\"&gt;just barely started&lt;/a&gt; to re-implement\nthe entire index feature by using RocksDB directly for the secondary indexes. RocksDB is a mutable KV store, so we can\nupdate documents in place without retaining the history‚Äîa useful feature for our main source-of-truth database;\nless critical for these indexes.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;That work is now done. Check out &lt;a href=\"https://github.com/jacobobryant/biff/blob/a3acee38b7976fa928151cf2e15f4632e58eb1d1/src/com/biffweb/impl/index.clj\"&gt;the\ncode&lt;/a&gt;\nand\n&lt;a href=\"https://github.com/jacobobryant/biff/blob/a3acee38b7976fa928151cf2e15f4632e58eb1d1/test/com/biffweb/impl/index_test.clj\"&gt;the\ntests&lt;/a&gt;.\nFrom users' perspective, the main change is that your indexer functions‚Äîwhich take in your XTDB transactions as\ninput, and create custom indexes/derived data/materialized views as output‚Äînow return maps instead of XTDB\ntransactions. The map keys and values are serialized to bytes (via Nippy for the values, and via a &lt;a href=\"https://github.com/jacobobryant/biff/blob/a3acee38b7976fa928151cf2e15f4632e58eb1d1/src/com/biffweb/impl/index.clj#L27\"&gt;custom\nfunction&lt;/a&gt;\nfor keys since we need the serialization to be stable) and stored in RocksDB.&lt;/p&gt;\n&lt;p&gt;On the usage side, there's a nifty &lt;code&gt;biff/open-db-with-index&lt;/code&gt; function that's similar to &lt;code&gt;xt/open-db&lt;/code&gt;, except that the\n&lt;code&gt;db&lt;/code&gt; value it returns &lt;em&gt;also&lt;/em&gt; lets you query a snapshot of your RocksDB index:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-clojure\"&gt;(with-open [db (biff/open-db-with-index ctx)]\n  ;; Query xt\n  (xt/q db ...)\n  ;; Read from your index\n  (biff/index-get db :my-index-id :some-key))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And Biff ensures that the two snapshots are consistent; i.e. the Biff index snapshot was built from all the transactions that\nthe XT snapshot was and none more.&lt;/p&gt;\n&lt;p&gt;Now that indexes are ready to go, I'm back to working on &lt;a href=\"https://yakread.com\"&gt;Yakread&lt;/a&gt;. I'm doing a complete rewrite\nusing both the new indexes feature and Pathom to make the code base more maintainable. When the rewrite is done I'll\nmake another release of Biff with all the index + Pathom features, then I'll release Yakread as open-source and use it\nas a &amp;quot;flagship&amp;quot; example Biff app. I probably won't emphasize indexes or Pathom in e.g. the tutorial, since for a lot of\nBiff users they would probably just complicate things unnecessarily. But I will likely write some documentation about\nusing Biff for &amp;quot;serious&amp;quot;/commercial projects that are expected to grow large.&lt;/p&gt;\n&lt;p&gt;So far I'm organizing Yakread's source code into three main folders/namespaces:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;com.yakread.model.*&lt;/code&gt;: this contains indexes and Pathom resolvers. The resolvers handle most of the database/index\naccess for your application.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;com.yakread.app.*&lt;/code&gt;: this part &lt;em&gt;also&lt;/em&gt; contains a bunch of Pathom resolvers, but instead of returning &amp;quot;regular&amp;quot; data,\nthey return HTML (hiccup) snippets. Each page you navigate to in the app is generated by wiring up a bunch of\ndifferent resolvers. This is where I also put the non-GET HTTP routes, scheduled tasks, and other\napplication-feature type things.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;com.yakread.lib.*&lt;/code&gt;: this is where most of the business logic/helper functions go. Each child namespace (e.g.\n&lt;code&gt;com.yakread.lib.user&lt;/code&gt;) is treated as its own independent library, with a public API and a private implementation.\n&lt;code&gt;model&lt;/code&gt; and &lt;code&gt;app&lt;/code&gt; code can both require namespaces from &lt;code&gt;lib&lt;/code&gt;, but not the other way around.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Once this is all done there a few other things I'd like to explore in the realm of making-Biff-suitable-for-large-apps,\nlike &amp;quot;how do you handle complex forms with dozens of fields and conditional logic etc&amp;quot; and &amp;quot;how do you gradually add\nmore client-side interactivity to your app without rewriting the whole thing in React?&amp;quot;&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/rocksdb-indexes-yakread/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry><entry><title type=\"html\">Speeding up page loads with secondary indexes</title><id>https://biffweb.com/p/indexes-2/</id><updated>2024-08-31T10:30:00.000Z</updated><content type=\"html\">&lt;p&gt;Continuing my &lt;a href=\"https://biffweb.com/p/indexes-prerelease\"&gt;previous work&lt;/a&gt; on using XTDB's secondary indices\nto handle derived data, I've started using them to re-implement various parts of &lt;a href=\"https://yakread.com\"&gt;Yakread&lt;/a&gt;.\nI started with the &lt;a href=\"https://yakread.com/subscriptions\"&gt;subscriptions page&lt;/a&gt;. This shows a list of all newsletters and RSS\nfeeds you've subscribed to. It sorts them based on when the most recent post was published and it tells you how many\nunread posts there are.&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"https://biffweb.com/images/subs-page.png\" alt=\"Yakread subscriptions page\" /&gt;&lt;/p&gt;\n&lt;p&gt;I originally implemented this by simply querying for each post and counting how many are unread etc. each time you load\nthe page. As such, it's slow as molasses: the page takes 13 seconds to load for my account. A more traditional approach\nto make this faster would probably be to update various parts of the codebase so that they keep track of all the derived\ndata we need. Each subscription could have a field for the number of unread posts which would be incremented/decremented\nwhenever you open a post or mark it as unread. And so on.&lt;/p&gt;\n&lt;p&gt;With Biff's not-yet-released indexes feature, I've instead written an &amp;quot;indexer function&amp;quot; which takes in transactions\nfrom XTDB's transaction log and uses them to build up a second database of derived data. Like event sourcing. The\n&lt;a href=\"https://gist.github.com/jacobobryant/b6475405693379e334b4c4bbb3a38f07#file-index-example-clj-L21\"&gt;indexer code&lt;/a&gt; is\npretty convoluted, but hopefully it's still a better experience than having to spread the logic out across your whole\ncodebase. And the result is marvelous: loading all my subscription data takes only 100ms - 150ms now, a 100x\nimprovement. I should be able to further reduce the query time with some more updates I've got planned.&lt;/p&gt;\n&lt;p&gt;&amp;quot;Updates&amp;quot; might actually be a bit of an understatement: as nice as this first step went, I need to redo the whole\nfeature. Currently the secondary indexes are also stored in XTDB‚Äîso you have your main XTDB instance, and then\nanother XTDB instance (using filesystem persistence) for each secondary index you define. As I've started to make\nadditional indexes for Yakread, I've hit a problem with that approach.&lt;/p&gt;\n&lt;p&gt;Whenever you update a document in XTDB, the entire new document is added to the doc store. e.g. if you have &lt;code&gt;{:xt/id 1, :message &amp;quot;hello&amp;quot;}&lt;/code&gt; and then you update it to &lt;code&gt;{:xt/id 1, :message &amp;quot;how do you do&amp;quot;}&lt;/code&gt;, the doc store will retain both\nversions of the document, without structural sharing. If the document grows large and you make lots of small updates to\nit, that could start taking up a lot of disk space.&lt;/p&gt;\n&lt;p&gt;Normally that's not a big deal because you can just model your data in a way that doesn't involve accumulating a bunch\nof gigantic documents. For example, when Yakread checks an RSS feed for new posts, it creates a document that looks like\n&lt;code&gt;{:xt/id #uuid &amp;quot;...&amp;quot;, :post/url &amp;quot;https://example.com/my-post&amp;quot;, :post/rss-feed &amp;quot;https://example.com/rss&amp;quot;, ...}&lt;/code&gt;. If you\nwant to get a 1 -&amp;gt; n mapping for a particular RSS feed, you just query for all the documents that have &lt;code&gt;:post/rss-feed &amp;quot;https://example.com/rss&amp;quot;&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;The problem for Biff's secondary indexes is that queries are slower then looking up a single document, and we really\nneed these indexer functions to be &lt;em&gt;fast&lt;/em&gt;. Otherwise they'll bottleneck your app's write throughput. So as a rule,\nindexer functions only do &lt;code&gt;xt/entity&lt;/code&gt; calls (i.e. they only look up documents by their primary key), they don't do any\n&lt;code&gt;xt/q&lt;/code&gt; queries. Which, you know, is kind of a problem when you need to be able to ask &amp;quot;what posts are part of this RSS\nfeed&amp;quot; since some feeds can have thousands of posts. I don't want to have a single RSS feed document with thousands of\nreferences to other documents, all of which would have to be duplicated on disk every time the feed publishes another\npost.&lt;/p&gt;\n&lt;p&gt;Hence, I've &lt;a href=\"https://gist.github.com/jacobobryant/2afa53e33c5d658de79d431c30554521\"&gt;just barely started&lt;/a&gt; to re-implement\nthe entire index feature by using RocksDB directly for the secondary indexes. RocksDB is a mutable KV store, so we can\nupdate documents in place without retaining the history‚Äîa useful feature for our main source-of-truth database;\nless critical for these indexes. RocksDB &lt;em&gt;does&lt;/em&gt; support &lt;a href=\"https://github.com/facebook/rocksdb/wiki/Snapshot\"&gt;in-memory\nsnapshots&lt;/a&gt;, which means Biff can still give you a consistent view\nover your main XT database and your secondary indexes.&lt;/p&gt;\n</content><link href=\"https://biffweb.com/p/indexes-2/\" /><author><name>Jacob O'Bryant</name><uri>https://obryant.dev</uri></author></entry></feed>",
  :trace-redirects []}}
